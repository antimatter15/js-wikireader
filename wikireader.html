<style>
body {
  font-family: sans-serif, arial;
  font-size: 10pt;
}

pre {
  word-wrap: break-word;
}
</style>
<div style="padding: 10px; float: right; display:none" id="searchbox">
<input type="text" id="search" style="width: 100%; border: 1px solid gray;margin-bottom: 0" onkeyup="bs(this.value)" placeholder="Search here">
  <ol id="articles" style="font-size: small; border: 1px solid gray; width: 200px; margin-top: 0px; padding-top: 9px; padding-bottom: 10px; border-top: none">
    Start searching
  </ol>
</div>
<div id="page" style="padding: 10px">
<h1>How to use JS-WikiReader</h1>
<ol>
  <li>Run <tt>index.py &lt; bzcat simplewiki-20101104-pages-articles.xml.bz2</tt> to create index.txt and wiki.txt</li>
  <li>Drag and drop both <tt>index.txt</tt> and <tt>wiki.txt</tt> onto this page at the same time</li>
  <li>Search and read</li>
</ol>
</div>

<script src="render.js"></script>
<script>
var wiki,index;


function slugfy(text){
  //a port of the python one
  return text
        .toLowerCase()
        .replace(/([a-zA-Z])(uml|acute|grave|circ|tilde|cedil)/g, '$1')
        .replace(/[^a-zA-Z0-9_]/g, ' ')
        .replace(/ +/g, '')
        .trim()
}

RegExp.escape = function(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}

var lq = '';
function bs(orig){
  var query = slugfy(orig);
  if(query.length > 0 && lq != query){
    lq = query;
    binsearch(0, index.size, query, function(start, len){
      showresults(start, len, orig);
    })
  }
}

function loadArticle(name){ //note: this is EXACT name
  binsearch(0, index.size, slugfy(name), function(start, len, query){  
    console.log('final stage',start,len);
    var fr = new FileReader();
    fr.onload = function(){
      var arr = fr.result.split('\n').slice(1,-1); //abandon the first one. and the last one.
      var matches = arr.map(function(i){
        var title = i.split(';')[1];
        var dist = damlev(title, name);
        return [dist, i]
      }).sort(function(a,b){
        return a[0] - b[0]
      })
      .map(function(i){
        return i[1]
      })
      
      var p = document.getElementById('page');
      if(matches.length == 0){
        p.innerHTML = 'Error 404. Article "'+name+'" not found.'
        return 
      }
      var m = matches[0].split(';');
      var title = m[1];
      var start = m[2];
      var len = m[3];
      
      console.log('loading article', title, start, len);
      
      var wr = new FileReader();
      wr.onload = function(){
        p.innerHTML = '<h1>'+title+'</h1>'+ wikiParse(wr.result);
        p.innerHTML += '<pre>'+wr.result+'</pre>';
        
        var rere = /\#REDIRECT\s*\[\[([^\]]+)\]\]/i; //redirect regex
        if(rere.test(wr.result)){
          loadArticle(wr.result.match(rere)[1])
        }
      }
      var miniblob = wiki.slice(start, len);
      wr.readAsText(miniblob,'utf-8');
    }
    var miniblob = index.slice(start, 10000);
    fr.readAsText(miniblob,'utf-8');
  })
}

function showresults(start, len, query){
  console.log('final stage',start,len);
  var fr = new FileReader();
  fr.onload = function(){
    var arr = fr.result.split('\n').slice(1,-1); //abandon the first one. and the last one.

    var re = new RegExp('^'+ RegExp.escape(slugfy(query)));
    var art = document.getElementById('articles');
    art.innerHTML = '';
    var leven = [];
    //console.log(arr);
    var matches = arr.filter(function(i){ //this could probably be optimized
      if(re.test(i)){
        return true
      }else{
        var title = i.split(';')[1];
        var dist = damlev(title.substr(0,query.length), query) + damlev(title, query) / 2;

        leven.push([dist, i]);
      }
    }).sort(function(b,a){
      var bx = b.split(';'), ax = a.split(';');
      
      return damlev(bx[1], query) - damlev(ax[1], query) //a.split(';')[3] - b.split(';')[3] //sort by file size
    })

    matches = matches.concat(leven
      .sort(function(a,b){return a[0] - b[0]})
      .map(function(i){return i[1]})
    );
    
    var articles = {};
    matches.filter(function(item, index){
      var t = item.split(';')[2]; //position where article starts
      if(articles[t]) return false;
      articles[t] = true;
      return true;
    })
    
    
    matches.forEach(function(item, index){
      var li = document.createElement('li');
      li.innerHTML = item.split(';')[1];
      art.appendChild(li);
    });
    
    if(matches.length == 0){
      art.innerHTML = 'No results :('
      return;
    }
    
    var m = matches[0].split(';');
    var title = m[1];
    var start = m[2];
    var len = m[3];
    
    loadArticle(title);
  }
  var miniblob = index.slice(start, 10000);
  //console.log(midpoint, miniblob, fr)
  fr.readAsText(miniblob,'utf-8');

}

var win = 200; //longest wikipedia article title is 208 char.

var lastresult = [0,0,0]; //a very simple cache

function binsearch(start, len, query, callback){
  if(lastresult[2] == query){
    console.log('pulling data from cache');
    return callback(lastresult[0], lastresult[1], lastresult[2]);
  }
  var fr = new FileReader();
  
  if(len < 10000){
    lastresult = [start,len,query];
    callback(start, len, query)
    
    return;
  }
  fr.onload = function(){
    var arr = fr.result.split('\n');
    if(arr.length < 3) console.log('error less than three parts', arr);
    var mid = arr[1]; //this should be complete;
    //console.log(arr);
    if(mid > query){
      //console.log(mid, '>', query)
      binsearch(start, Math.round(len/2) + win, query, callback);
    }else{
      //console.log(mid, '<', query)
      binsearch(start + Math.round(len/2) - win, Math.round(len/2), query, callback);
    }
  }
  var midpoint = Math.round(start + len/2);
  var miniblob = index.slice(midpoint - win, 2 * win);
  //console.log(midpoint, miniblob, fr)
  fr.readAsText(miniblob,'utf-8');
}


ondragover=function(){return false}
ondrop=function(e){
  if(e.dataTransfer.files.length == 2){
    var files = e.dataTransfer.files;
    if(files[0].size > files[1].size){
      wiki = files[0];
      index = files[1];
    }else{
      wiki = files[1];
      index = files[0];
    }
    document.getElementById('searchbox').style.display = '';
  }else{
    alert('wrong number of files. needed to get two. sorted index and wiki')
  }
  return false
}

//another version by me: http://snippets.dzone.com/posts/show/6942
//based on: http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance
//and:  http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
function damlev( str1, str2 ){
  if(!str1)str1="";
  if(!str2)str2="";

	var i, j, cost, d = [];
  str1 = str1.split("");
  str2 = str2.split("");
	
	if (str1.length == 0) return str2.length;
	if (str2.length == 0) return str1.length;
	
	for (i = 0; i <= str1.length; i++){
		d[ i ] = new Array();
		d[ i ][ 0 ] = i;
	}
 
	for (j = 0; j <= str2.length; j++) d[ 0 ][ j ] = j;
 
	for ( i = 1; i <= str1.length; i++ ){
		for ( j = 1; j <= str2.length; j++ ){
			cost = str1[i - 1] != str2[j - 1]; //false == 0, true == 1

			d[ i ][ j ] = Math.min(
                            d[ i - 1 ][ j ] + 1,
                            d[ i ][ j - 1 ] + 1,
                            d[ i - 1 ][ j - 1 ] + cost
                            );
			if(i > 1 && j > 1 && str1[i-1] == str2[j-2] && str1[i-2] == str2[j-1]){
        d[i][j] = Math.min(
                          d[i][j],
                          d[i-2][j-2] + cost   // transposition
                          )
       }
		}
	}
	
	return d[str1.length][str2.length];
}
</script>
