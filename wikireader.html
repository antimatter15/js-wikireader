<style>
body {
  font-family: sans-serif, arial;
  font-size: 10pt;
}
</style>
<div style="padding: 10px; float: right; ">
<input type="text" id="search" style="width: 100%; border: 1px solid gray;" onkeyup="bs(this.value)" placeholder="Search here">
  <ol id="articles" style="font-size: small; border: 1px solid gray; width: 200px;">
    <li>Start searching</li>
  </ol>
</div>
<div id="page" style="padding: 10px">
<h1>How to use JS-WikiReader</h1>
<ol>
  <li>Run <tt>index.py &lt; bzcat simplewiki-20101104-pages-articles.xml.bz2</tt> to create index.txt and wiki.txt</li>
  <li>Drag and drop both <tt>index.txt</tt> and <tt>wiki.txt</tt> onto this page at the same time</li>
  <li>Search and read</li>
</ol>
</div>

<script src="render.js"></script>
<script>
var wiki,index;


function slugfy(text){
  //a port of the python one
  return text
        .toLowerCase()
        .replace(/([a-zA-Z])(uml|acute|grave|circ|tilde|cedil)/g, '$1')
        .replace(/[^a-zA-Z0-9_]/g, ' ')
        .replace(/ +/g, '')
        .trim()
}

RegExp.escape = function(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}

function bs(query){
  if(query.length > 1){
    binsearch(0, index.size, slugfy(query))
  }
}
var win = 200; //longest wikipedia article title is 208 char.
function binsearch(start, len, query){
  var fr = new FileReader();
  if(len < 10000){
    console.log('final stage',start,len);
    fr.onload = function(){
      var arr = fr.result.split('\n').slice(1,-1); //abandon the first one. and the last one.
      var re = new RegExp('^'+ RegExp.escape(query));
      var art = document.getElementById('articles');
      art.innerHTML = '';
      var leven = [];
      //console.log(arr);
      var matches = arr.filter(function(i){ //this could probably be optimized
        if(re.test(i)){
          return true
        }else{
          var dist = damlev(i.substr(0,query.length), query);
          if(dist < query.length * 0.5){
            leven.push([dist, i]);
          }
        }
      })

      matches = matches.concat(leven
        .sort(function(a,b){return a[0] - b[0]})
        .map(function(i){return i[1]})
      );
      
      matches.forEach(function(item, index){
        var li = document.createElement('li');
        li.innerHTML = item.split(';')[1];
        art.appendChild(li);
      });
      
      
      var m = matches[0].split(';');
      var title = m[1];
      var start = m[2];
      var len = m[3];
      
      console.log('loading article', title, start, len);
      
      var wr = new FileReader();
      wr.onload = function(){
        var p = document.getElementById('page');
        p.innerHTML = '<h1>'+title+'</h1>'+ wikiParse(wr.result);
        p.innerText += wr.result;
      }
      var miniblob = wiki.slice(start, len);
      wr.readAsText(miniblob,'utf-8');
      //console.log(matches)
    }
    var miniblob = index.slice(start, 10000);
    //console.log(midpoint, miniblob, fr)
    fr.readAsText(miniblob,'utf-8');
    
    return;
  }
  fr.onload = function(){
    var arr = fr.result.split('\n');
    if(arr.length < 3) console.log('error less than three parts', arr);
    var mid = arr[1]; //this should be complete;
    //console.log(arr);
    if(mid > query){
      //console.log(mid, '>', query)
      binsearch(start, Math.round(len/2) + win, query);
    }else{
      //console.log(mid, '<', query)
      binsearch(start + Math.round(len/2) - win, Math.round(len/2), query);
    }
  }
  var midpoint = Math.round(start + len/2);
  var miniblob = index.slice(midpoint - win, 2 * win);
  //console.log(midpoint, miniblob, fr)
  fr.readAsText(miniblob,'utf-8');
}


ondragover=function(){return false}
ondrop=function(e){
  if(e.dataTransfer.files.length == 2){
    var files = e.dataTransfer.files;
    if(files[0].size > files[1].size){
      wiki = files[0];
      index = files[1];
    }else{
      wiki = files[1];
      index = files[0];
    }
    document.getElementById('search').style.display = '';
  }else{
    alert('wrong number of files. needed to get two. sorted index and wiki')
  }
  return false
}

//another version by me: http://snippets.dzone.com/posts/show/6942
//based on: http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance
//and:  http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
function damlev( str1, str2 ){
  if(!str1)str1="";
  if(!str2)str2="";

	var i, j, cost, d = [];
  str1 = str1.split("");
  str2 = str2.split("");
	
	if (str1.length == 0) return str2.length;
	if (str2.length == 0) return str1.length;
	
	for (i = 0; i <= str1.length; i++){
		d[ i ] = new Array();
		d[ i ][ 0 ] = i;
	}
 
	for (j = 0; j <= str2.length; j++) d[ 0 ][ j ] = j;
 
	for ( i = 1; i <= str1.length; i++ ){
		for ( j = 1; j <= str2.length; j++ ){
			cost = str1[i - 1] != str2[j - 1]; //false == 0, true == 1

			d[ i ][ j ] = Math.min(
                            d[ i - 1 ][ j ] + 1,
                            d[ i ][ j - 1 ] + 1,
                            d[ i - 1 ][ j - 1 ] + cost
                            );
			if(i > 1 && j > 1 && str1[i-1] == str2[j-2] && str1[i-2] == str2[j-1]){
        d[i][j] = Math.min(
                          d[i][j],
                          d[i-2][j-2] + cost   // transposition
                          )
       }
		}
	}
	
	return d[str1.length][str2.length];
}
</script>
